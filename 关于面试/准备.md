十二月之前

一、基础打牢，数据结构和算法，重新定义

二、Java基础，重新全部背下来

三、数据库完全搞定





面试

1.数据结构和算法方面

数据结构 搞定 红黑树   B树 B+树  还有堆和栈 的相关方面

算法方面，深度优先搜索 广度优先搜索 回溯算法 贪心算法



垃圾回收和类加载

红黑树和B树



2.技术方面

Java  垃圾回收机制搞定 

对象的生命周期 创建  可触及状态  不可触及状态 不可触及状态  回收

数据引用类型 四种引用 

类加载过程   类加载  类连接（类验证 准备 解析）  类初始化

类加载器 父亲委派机制  根加载器 扩展加载器 系统加载器 自定义加载器 

垃圾回收算法 什么时候用到那个算法 

最基本的垃圾收集算法

标记-清除算法，第一步标记出所有需要回收的对象，然后统一回收

缺点，效率比较低，标记和清除的效率都不是特别高，清除后会产生大量的不连续的内存，空间碎片也会比较多。当大对象分配内存时，会再一次进行垃圾回收。



复制算法

将内存按容量划分为大小相等的两块，每次只用其中的一块，当这块内存用完了，将这块内存上的还活着的对象移到另一块内存上。实现简单，运行高效。但是降低了内存的利用率，再分配大对象的时候，同样会有效率低下的问题



标记-整理算法

第一步将所有需要回收的对象全部进行标记，然后将活着的对象全部移到内存的一侧，然后清除没有用的对象。



分代收集算法

根据对象存活时间，将Java对象分为新生代和老年代，根据这个特点，将堆分为新生堆和老年堆，这样新生堆中就会一直回收，老年堆里几乎不会进行回收。



四种垃圾回收算法都是由垃圾收集器执行的

1. Serial 收集器 最古老、稳定以及效率高的收集器 可能会产生较长的停顿  只用一个线程去回收 分代收集算法  新生代采用复制算法  老年代采用标记清除算法

2. `ParNew`收集器

   Serial 收集器的多线程版本

3. Parallel 收集器 新生代 复制算法 老年代采用 标记整理算法

4. `G1` 收集器

   内存布局不仅是新生代和老年代的物理隔阂

这只是垃圾回收算法的一部分，要完全搞定





数据结构和算法 



类加载

垃圾回收





什么是线程安全的。

实现线程安全的几种设计方式

1. 不可变
2. 互斥同步
3. 非阻塞同步
4. 无同步方案

锁优化

1. 自旋锁和自适应锁
2. 锁消除
3. 锁粗化
4. 轻量级锁
5. 偏向锁

