`JVM` 类加载

一个类的生命周期

<img src="G:\笔记\关于面试\类的生命周期.png" alt="类的生命周期" style="zoom:80%;" />

在这个过程中，只有类加载、类验证、类准备、类初始化和类卸载的顺序是固定的。类加载的顺序必须按照这个顺序进行。但是其中类解析的出场顺序是一定的，一般情况是按照图上所示的顺序进行，在初始化之前，也有在初始化之后的情况。，这是为了Java语言的运行时绑定特性，动态绑定。

***类加载时机***

什么时候进行第一步类加载，在Java虚拟机中没有强制的约束，这根据`JVM` 的具体实现细节来进行把握。

但是对类初始化时机，`jvm`有明确的规定，共有六种情况。

1. 遇到`new` `getstatic` `putstatic` `invokestatic` 这几条字节码指令时。能生成这几天字节码指令的场景有。
   - 使用`new` 关键字实例化对象的时候
   - 读取一个类的静态字段的时候。（被`final` 修饰，一再编译器，把结果放进常量池的静态字段除外）
   - 调用一个类的静态方法的时候。
2. 使用反射类的包的方法对类型进行反射调用的时候。
3. 当初始化子类，发现其父类还没进行初始化的时候，需要先初始化其父类。
4. 当虚拟机启动时，会初始化主类，含有`main` 方法的类。
5. `invoke` 解析实例，如果发现该实例所在的类没有初始化，会对其进行初始化。
6. 如果接口的实现类被初始化，该接口要被初始化，抽象类也是如此。

总结就是，当Java虚拟机对某个类进行主动引用的时候，`JVM` 会初始化这个类，其余都属于被动引用。

Java中对一个类的主动引用，就只有以上六种场景。

1. 当引用子类的父类静态变量时，不会初始化子类。因为这属于被动引用。 
2. 初始化对象数组的时候，这里并没有对创建对象，同样也是不会初始化对象所属的类。
3. 当用到一个类的静态属性时，但是该属性是由`final` 关键字修饰的，这里不会初始化该类，因为这个属性在编译时就已经放进常量池中了。



***类加载的过程***

**第一个阶段 加载**

1. 通过一个类的全限定名来获取定义该类的二进制字节流。
2. 将这个字节流所表示的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 `java.lang.class` 作为方法区这个类的各种方法的接口。

**第二个阶段 验证**

验证二进制字节流是否是正确的，从以下几个方面进行验证。

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

**第三个阶段 准备**

正式为类中定义的变量（静态变量）分配内存，并且对类变量设置从初始值。这个类变量并不是实例变量（类的属性），实例变量是在对象初始化的时候才会进行分配。

**第四阶段  解析**

该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。直接引用是可以直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。

**第五阶段  初始化**

执行静态代码块，初始化类的静态属性和类的静态方法





***类加载器***

类加载器和累加载过程中的加载有很大的关系，在整个类加载过程中，`JVM`团队有意将加载的过程放在`JVM` 的外面去执行，让程序员自己去决定如何去获取所需的类，实现这个动作的代码被称为类加载器 `Class loader`。

类与类加载器



类加载器虽然只有来实现类的加载动作，但是在Java程序中起到的作用却远超类加载阶段，用来判断对象是否相等，只有两个对象是同一个类的实例的时候才有意义，这就通过类加载器来实现的。另外还有 在使用 `instanceof` 关键字的时候 ，在Java中，很多的过程几乎都会用到类加载器。



双亲委派模型



如果一个类加载器收到了类加载的请求，他首先不会去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因为所有的加载器都是由最顶层的启动类去完成，只有当父加载器找不到的时候，子加载器才会去完成，先上去再下来。

这样的好处就是类随着类加载器有了优先级，最顶层的类加载器优先级最高，一次往下排。

举个例子，假设我写了一个`Object`类，我们再创建一个`Object` 类对象，此时我们因为`JDK` 中的`Object` 类优先级高，不会创建的不会是我写出来的这个类对象，也就是说我能重载`JDK` 已经实现的类

