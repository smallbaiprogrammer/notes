Java中的`I/O` 流分几种

按方向分类，输入流，输出流

按操作单元分类，字符流，字节流

Java中`I/O` 流很多类，但都是四个抽象基类衍生出来的

- `InputStream/Reader` 所有输入流的祖先就是肯定是这两个抽象类，前面就是字节流，后面是字符流
- `OutputStream/Writer`  同样所有输出流的祖先

`BIO、NIO、AIO ` 三种模型，这三种模型几乎不会用到

`BIO` 模型 `（Blocking I/O）` 同步阻塞模型 

写入和读取只能在同一个线程内完成，也就是说，每一个客户端连接都需要一个单独的线程来完成，传统的服务器-客户端模型，服务器端每个线程连接获取一个连接。但是获取线程和销毁线程，代价是很大的，尽管可以使用线程池进行优化，但是代价依然很大，当并发数量变高时，这种模型就会崩掉。

`NIO` 多路复用模型 `（NON Blocking I/O）` 

该模型是采用了单线程轮询事件的机制，通过高效定位就绪的`channel` 来决定做什么，这样避免了大量客户端连接时造成的线程频繁切换的问题，该模型的并发能力更优一点。

`AIO` 模型，异步非阻塞的`I/O` 模型，基于事件和回调机制实现的，应用操作之后会直接返回不会阻塞在哪里。当后台处理完了，会通知相应的线程进行后续的操作。