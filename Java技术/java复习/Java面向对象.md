面向对象 

方法的重载和方法的重写

overload 重载 和 override 重写 

重载根据输入参数的类型

类的构造方法，多个构造方法

创建对象时，会发生什么

内存分为两个空间 栈空间 和 堆 空间 

在堆开辟一个空间，然后栈内开辟一个空间，值为默认值

然后调用构造方法，将对象在堆中的地址发给栈中的变量

对象的实例变量是存在堆中的对象地址和变量名是栈中的

构造方法

如果类中，没有创建构造方法，那么会继承默认的空参数构造方法，如果添加了一个构造方法，那么就不会继承默认构造方法了

this 关键字的用法

第一种用法，调用实例属性，实例方法  this.实例属性 或者 this.实例方法

第二种用法，调用本类中的其他构造方法    this（） 或 this（实参）

面向对象的三大特性

封装性

类的实例数据全部设为private 不可直接进行访问，更不可以直接修改，这就是面向对象的封装性

但是要怎么对对象的私有数据进行修改和访问呢？

所有就要设置set方法和get方法，来修改私有变量和访问私有变量

而且，我们我们可以在方法通过代码来限制访问，或者限制修改，这样非常明显地体现了面向对象的封装性



继承性

父类不可以被继承的

父类的构造方法不能被继承

父类子类不在同一个包中，父类的默认熟悉和方法

访问修饰符一共分为四种，private > protected > default > public 保护性从高到底 

default 是指默认的类，也就是没有添加修饰符的类，该类不需要添加修饰符，默认就是该修饰符

父类的熟悉，如果是private ，子类不能直接访问

private 只能本类中才可以访问，子类不可以，同一个包下的类也是不可以的

protected 本类和同胞类子类都可以进行访问，其他类能访问。

default 默认 本类和同包下的类 子类也不可以

public 任何类都可以进行访问

这里要注意 能否访问的意思 能否访问是指并不是指直接采用该类的名称，而是采用对应类的对象也是不可以访问的，这个是重点，另外在Java中，不是任何局部变量和全局变量，全局变量只能以该类的对象的形式进行出现，在类中访问其他的全局变量，也是需要对象的，只要类中的静态变量才可以以类名。变量名进行访问，但是静态变量同样也是受权限关键字进行保护的



方法的覆盖 也叫做重写

override 

重新的方法的权限修饰符不能比父类的权限更小，只能更大



super 关键字

在子类中，可直接访问从父类中继承到的属性和方法，但如果子类中覆盖了父类的方法和属性，则需要采用suoer关键字来访问父类的构造方法，



对象创建的过程中 先创建父类对象，然后构造子类对象，所有没有类创建时最先创建的一定是object 类，也就是先运行父类的构造方法，然后运行子类的构造方法

此过程在内存中的过程

现在栈中创建一个父类对象，该对象指向堆，堆中创建父类的属性，然后创建子类的构造方法，堆中在父类中的数据中修改添加数据，相当于一层层往外修改

因为在子类中构造方法 运行的第一个构造方法时super，父类的无参构造方法， 默认的，你不添加，就是隐式写在上面，你也可以自己写，这样你可以根据自己的需要创建父类的有参构造方法，所以解锁这样一个知识点，当你在父类中写了多个有参构造方法时，没写无参构造方法，子类中必须采用super关键调用父类的带参构造方法，因为此时父类没有无参构造方法了。

this 关键字 表示当前对象的引用，super 表示父类的 引用，而且这两关键字不能同时使用，



多态性



多态是如何理解的，子类实例既是子类的实例，也是父类的实例

而且采用多态只能采用父类的属性和方法，不可以调用子类中的方法和属性

在多态中，子类重写了父类的方法，此时多态对象调用了父类的方法，实际是调动了子类重写后的方法。

这是多态方法的根本，

在一个方法形式参数为父类，在执行方法时，根据输入的对象来运行每个对象对应的方法

这是多态的第一个应该场景，使用父类作为方法形参实现多态，使方法参数的类型更为宽泛

第二个场景，使用父类作为方法返回值实现多态，是方法可以返回不同子类，这里存在一个缺点，就是返回的子类不能访问子类的属性和方法，但是也存在一定的优势

```java
public Animal buy(int i){
    if (i==1){
        return new Bird();
    }else if (i == 2){
        return new Dog();
    }else {
        return new Animal();
    }
}
```



类型的强制转换，对象的强制转换

向上类型转换，装箱

这个在多态中是常用的，这个就只能调用父类的构造方法 

向下类型转换，拆箱

父类转为子类，这个必须是向上转型才能向下进行强转的，直接创建的父类对象是不能强转为子类对象的

```java
// 向上转型// 装箱 是可以的
Animal animal = new Dog();
// 经过向上转型，然后可以向下转型,这样是可以的
Dog dog1 = (Dog)animal;

// 如果直接创建一个 父类对象
Animal animal1 = new Animal();
// 这样是不对的 会报错，类型转换异常
Dog dog2 = (Dog) animal1;
```



我们可以使用关键字查看向上转型之后得到的对象的真是类型

```java
Animal animal = new Dog();
 Dog dog1 = (Dog)animal;
// 使用instanceof 关键字
boolean b = animal instanceof Dog;
System.out.println(b);
```

多态的作用，屏蔽了子类间的差异性，程序会变的灵活，而且耦合度会降低